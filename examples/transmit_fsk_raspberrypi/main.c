#include <fcntl.h>
#include <inttypes.h>
#include <linux/gpio.h>
#include <linux/spi/spidev.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sx127x.h>
#include <sys/ioctl.h>
#include <sys/poll.h>
#include <unistd.h>
#include <time.h>
#include <errno.h>

// Correspond to SPI0 with chip select pin CE0 (GPIO8) on RaspberryPI
#define SPI_DEVICE "/dev/spidev0.0"
#define GPIO_DEVICE "/dev/gpiochip0"
#define GPIO_DIO1_PIN 13
#define GPIO_DIO2_PIN 19
#define GPIO_DIO3_PIN 26
#define GPIO_DIO4_PIN 5
#define GPIO_DIO0_PIN 27
#define GPIO_RESET_PIN 6
#define GPIO_POLL_TIMEOUT (-1)
#define TEST_FREQUENCY 868200000
#define LINUX_ERROR_CHECK(x)                                                       \
  do {                                                                             \
    int __err_rc = (x);                                                            \
    if (__err_rc != 0) {                                                           \
      fprintf(stderr, "failed at %s:%d code: %d\n", __FILE__, __LINE__, __err_rc); \
      return EXIT_FAILURE;                                                         \
    }                                                                              \
  } while (0)

#define LINUX_NO_CODE_ERROR_CHECK(x)                                               \
  do {                                                                             \
    int __err_rc = (x);                                                            \
    if (__err_rc != 0) {                                                           \
      fprintf(stderr, "failed at %s:%d code: %d\n", __FILE__, __LINE__, __err_rc); \
      return;                                                                      \
    }                                                                              \
  } while (0)

int messages_sent = 0;
int total_messages = 7;

int msleep(long msec) {
  struct timespec ts;
  int res;

  if (msec < 0) {
    errno = EINVAL;
    return EXIT_FAILURE;
  }

  ts.tv_sec = msec / 1000;
  ts.tv_nsec = (msec % 1000) * 1000000;

  do {
    res = nanosleep(&ts, &ts);
  } while (res && errno == EINTR);

  return res;
}

void tx_callback(void *ctx) {
  sx127x *device = (sx127x *)ctx;
  if (messages_sent > 0) {
    fprintf(stdout, "transmitted\n");
    msleep(1000);
  }
  if (messages_sent == 0) {
    uint8_t data[] = {0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00};
    LINUX_NO_CODE_ERROR_CHECK(sx127x_fsk_ook_tx_set_for_transmission(data, sizeof(data), device));
  } else if (messages_sent == 1) {
    uint8_t data[] = {0xFF, 0x00};
    LINUX_NO_CODE_ERROR_CHECK(sx127x_fsk_ook_tx_set_for_transmission(data, sizeof(data), device));
  } else if (messages_sent == 2) {
    uint8_t data[] = {0xAA, 0xAA, 0xFF, 0xFF, 0x00, 0x00};
    LINUX_NO_CODE_ERROR_CHECK(sx127x_fsk_ook_tx_set_for_transmission(data, sizeof(data), device));
  } else if (messages_sent == 3) {
    // 63 bytes max for variable to fit into FIFO
    uint8_t data[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d,
                      0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e};
    LINUX_NO_CODE_ERROR_CHECK(sx127x_fsk_ook_tx_set_for_transmission(data, sizeof(data), device));
  } else if (messages_sent == 4) {
    // 255 bytes will trigger batches
    uint8_t data[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d,
                      0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b,
                      0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,
                      0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
                      0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5,
                      0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe};
    LINUX_NO_CODE_ERROR_CHECK(sx127x_fsk_ook_tx_set_for_transmission(data, sizeof(data), device));
  } else if (messages_sent == 5) {
    // 62 bytes max for variable with address to fit into FIFO
    uint8_t data[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d,
                      0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d};
    LINUX_NO_CODE_ERROR_CHECK(sx127x_fsk_ook_tx_set_for_transmission_with_address(data, sizeof(data), 0x11, device));
  } else if (messages_sent == 6) {
    // 254 byte with address will trigger batches
    uint8_t data[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d,
                      0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b,
                      0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,
                      0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
                      0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5,
                      0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd};
    LINUX_NO_CODE_ERROR_CHECK(sx127x_fsk_ook_tx_set_for_transmission_with_address(data, sizeof(data), 0x11, device));
  } else {
    // FSK mode require manual switch from TX to Standby
    LINUX_NO_CODE_ERROR_CHECK(sx127x_set_opmod(SX127x_MODE_STANDBY, SX127x_MODULATION_FSK, device));
    messages_sent++;
    return;
  }
  LINUX_NO_CODE_ERROR_CHECK(sx127x_set_opmod(SX127x_MODE_TX, SX127x_MODULATION_FSK, device));
  fprintf(stdout, "transmitting\n");
  messages_sent++;
}

int gpio_write_value(int fd, int value) {
  struct gpiohandle_data data;
  data.values[0] = value;
  int code = ioctl(fd, GPIOHANDLE_SET_LINE_VALUES_IOCTL, &data);
  if (code < 0) {
    perror("unable to write value");
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}

int reset_sx127x() {
  int fd = open(GPIO_DEVICE, O_RDONLY);
  if (fd < 0) {
    perror("unable to open device");
    return EXIT_FAILURE;
  }
  struct gpiohandle_request rq;
  rq.lineoffsets[0] = GPIO_RESET_PIN;
  rq.lines = 1;
  rq.flags = GPIOHANDLE_REQUEST_OUTPUT;
  strcpy(rq.consumer_label, "sx127x_reset");
  int code = ioctl(fd, GPIO_GET_LINEHANDLE_IOCTL, &rq);
  if (code < 0) {
    perror("unable to reset chip");
    return EXIT_FAILURE;
  }
  close(fd);

  LINUX_ERROR_CHECK(gpio_write_value(rq.fd, 1));
  LINUX_ERROR_CHECK(gpio_write_value(rq.fd, 0));
  msleep(5);
  LINUX_ERROR_CHECK(gpio_write_value(rq.fd, 1));
  msleep(5);
  close(rq.fd);
  return EXIT_SUCCESS;
}

int setup_and_wait_for_interrupt(sx127x *device) {
  int fd = open(GPIO_DEVICE, O_RDONLY);
  if (fd < 0) {
    perror("unable to open device");
    return EXIT_FAILURE;
  }
  uint8_t gpios[] = {GPIO_DIO0_PIN, GPIO_DIO1_PIN, GPIO_DIO2_PIN, GPIO_DIO3_PIN, GPIO_DIO4_PIN};
  int gpios_length = sizeof(gpios);
  struct pollfd pfd[5];
  for (int i = 0; i < gpios_length; i++) {
    struct gpioevent_request rq;
    rq.lineoffset = gpios[i];
    if (gpios[i] == GPIO_DIO1_PIN) {
      rq.eventflags = GPIOEVENT_EVENT_FALLING_EDGE;
    } else {
      rq.eventflags = GPIOEVENT_EVENT_RISING_EDGE;
    }
    char label[] = "sx127x_fsk";
    memcpy(rq.consumer_label, label, sizeof(label));
    rq.handleflags = GPIOHANDLE_REQUEST_INPUT;

    int code = ioctl(fd, GPIO_GET_LINEEVENT_IOCTL, &rq);
    if (code < 0) {
      perror("unable to setup gpio interrupt");
      return EXIT_FAILURE;
    }

    pfd[i].fd = rq.fd;
    pfd[i].events = POLLIN;
  }
  close(fd);

  fprintf(stdout, "transmitting packets...\n");
  // send the first message
  tx_callback(device);
  char buffer[32] = {0};
  while (messages_sent <= total_messages) {
    int code = poll(pfd, gpios_length, GPIO_POLL_TIMEOUT);
    if (code < 0) {
      perror("unable to receive gpio interrupt");
      break;
    }
    for (int i = 0; i < gpios_length; i++) {
      if (pfd[i].revents & POLLIN) {
        // discard data
        read(pfd[i].fd, buffer, 32);
      }
    }
    sx127x_handle_interrupt(device);
  }
  for (int i = 0; i < gpios_length; i++) {
    close(pfd[i].fd);
  }
  return EXIT_SUCCESS;
}


int main() {
  LINUX_ERROR_CHECK(reset_sx127x());

  int spi_device_fd = open(SPI_DEVICE, O_RDWR);
  if (spi_device_fd < 0) {
    perror("unable to open device");
    return EXIT_FAILURE;
  }
  int mode = SPI_MODE_0;  // CPOL=0, CPHA=0
  LINUX_ERROR_CHECK(ioctl(spi_device_fd, SPI_IOC_WR_MODE, &mode));
  int bits_per_word = 0;  // means 8 bits
  LINUX_ERROR_CHECK(ioctl(spi_device_fd, SPI_IOC_WR_BITS_PER_WORD, &bits_per_word));
  int lsb_setting = 0;  // MSB
  LINUX_ERROR_CHECK(ioctl(spi_device_fd, SPI_IOC_WR_LSB_FIRST, &lsb_setting));
  int max_speed = 4000000;
  LINUX_ERROR_CHECK(ioctl(spi_device_fd, SPI_IOC_WR_MAX_SPEED_HZ, &max_speed));

  sx127x device;
  LINUX_ERROR_CHECK(sx127x_create(&spi_device_fd, &device));
  LINUX_ERROR_CHECK(sx127x_set_opmod(SX127x_MODE_SLEEP, SX127x_MODULATION_FSK, &device));
  LINUX_ERROR_CHECK(sx127x_set_frequency(TEST_FREQUENCY, &device));
  LINUX_ERROR_CHECK(sx127x_set_opmod(SX127x_MODE_STANDBY, SX127x_MODULATION_FSK, &device));
  LINUX_ERROR_CHECK(sx127x_fsk_ook_set_bitrate(4800.0, &device));
  LINUX_ERROR_CHECK(sx127x_fsk_set_fdev(5000.0, &device));
  LINUX_ERROR_CHECK(sx127x_set_preamble_length(4, &device));
  uint8_t syncWord[] = {0x12, 0xAD};
  LINUX_ERROR_CHECK(sx127x_fsk_ook_set_syncword(syncWord, 2, &device));
  LINUX_ERROR_CHECK(sx127x_fsk_ook_set_address_filtering(SX127X_FILTER_NONE, 0, 0, &device));
  LINUX_ERROR_CHECK(sx127x_fsk_ook_set_packet_encoding(SX127X_NRZ, &device));
  LINUX_ERROR_CHECK(sx127x_fsk_ook_set_packet_format(SX127X_VARIABLE, 255, &device));
  LINUX_ERROR_CHECK(sx127x_fsk_set_data_shaping(SX127X_BT_0_5, SX127X_PA_RAMP_10, &device));
  LINUX_ERROR_CHECK(sx127x_tx_set_pa_config(SX127x_PA_PIN_BOOST, 4, &device));
  LINUX_ERROR_CHECK(sx127x_fsk_ook_set_crc(SX127X_CRC_CCITT, &device));

  sx127x_tx_set_callback(tx_callback, &device, &device);

  return setup_and_wait_for_interrupt(&device);
}